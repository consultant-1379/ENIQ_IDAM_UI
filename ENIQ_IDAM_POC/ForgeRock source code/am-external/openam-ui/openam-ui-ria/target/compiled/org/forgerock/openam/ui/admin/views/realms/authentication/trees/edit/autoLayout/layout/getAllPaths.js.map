{"version":3,"sources":["../../../../../../../../../../../../../XUI/org/forgerock/openam/ui/admin/views/realms/authentication/trees/edit/autoLayout/layout/getAllPaths.jsm"],"names":["getAllPaths","nodeId","nodes","path","allPathsForNode","node","push","nodeConnections","connections","sort","outcomeId","path1","path2","length"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;AAUA,QAAMA,cAAc,SAAdA,WAAc,CAACC,MAAD,EAASC,KAAT,EAA8B;AAAA,YAAdC,IAAc,uEAAP,EAAO;;AAC9C,YAAMC,kBAAkB,EAAxB;;AAEA,YAAI,kBAAKD,IAAL,EAAW,UAACE,IAAD;AAAA,mBAAU,qBAAQA,IAAR,MAAkBJ,MAA5B;AAAA,SAAX,CAAJ,EAAoD;AAChD;AACAG,4BAAgBE,IAAhB,CAAqBH,IAArB;AACH,SAHD,MAGO;AACHA,iBAAKG,IAAL,qBAAaL,MAAb,EAAsBC,MAAMD,MAAN,CAAtB;;AAEA,gBAAMM,kBAAkBL,MAAMD,MAAN,EAAcO,WAAtC;AACA,gBAAI,qBAAQD,eAAR,CAAJ,EAA8B;AAC1BH,gCAAgBE,IAAhB,CAAqBH,IAArB;AACH,aAFD,MAEO;AACH,qCAAQ,kBAAKI,eAAL,EAAsBE,IAAtB,EAAR,EAAsC,UAACC,SAAD,EAAe;AACjD,yCAAQV,YAAYO,gBAAgBG,SAAhB,CAAZ,EAAwCR,KAAxC,EAA+C,mBAAMC,IAAN,CAA/C,CAAR,EAAqE,UAACA,IAAD,EAAU;AAC3EC,wCAAgBE,IAAhB,CAAqBH,IAArB;AACH,qBAFD;AAGH,iBAJD;AAKH;AACJ;;AAED,eAAOC,gBAAgBK,IAAhB,CAAqB,UAACE,KAAD,EAAQC,KAAR;AAAA,mBAAkBA,MAAMC,MAAN,GAAeF,MAAME,MAAvC;AAAA,SAArB,CAAP;AACH,KAtBD;;sBAwBeb,W","file":"getAllPaths.js","sourcesContent":["/*\n * The contents of this file are subject to the terms of the Common Development and\n * Distribution License (the License). You may not use this file except in compliance with the\n * License.\n *\n * You can obtain a copy of the License at legal/CDDLv1.0.txt. See the License for the\n * specific language governing permission and limitations under the License.\n *\n * When distributing Covered Software, include this CDDL Header Notice in each file and include\n * the License file at legal/CDDLv1.0.txt. If applicable, add the following below the CDDL\n * Header, with the fields enclosed by brackets [] replaced by your own identifying\n * information: \"Portions copyright [year] [name of copyright owner]\".\n *\n * Copyright 2017 ForgeRock AS.\n */\n\nimport { clone, find, findKey, forEach, isEmpty, keys } from \"lodash\";\n\n/**\n * This function recursivly iterates through the node's outcomes sorted by their ids and returns all\n * possible paths for it sorted by their length. If there are loops that are connected to the starting node, they will\n * be returned as well.\n *\n * @param {Object} nodeId node id to inspect\n * @param {Object} nodes Object of all nodes, indexed by node ID\n * @param {Object[]} [path=[]] path to add the node to\n * @returns {Array[]} array of all possible paths\n */\nconst getAllPaths = (nodeId, nodes, path = []) => {\n    const allPathsForNode = [];\n\n    if (find(path, (node) => findKey(node) === nodeId)) {\n        // if there is a loop detected\n        allPathsForNode.push(path);\n    } else {\n        path.push({ [nodeId]: nodes[nodeId] });\n\n        const nodeConnections = nodes[nodeId].connections;\n        if (isEmpty(nodeConnections)) {\n            allPathsForNode.push(path);\n        } else {\n            forEach(keys(nodeConnections).sort(), (outcomeId) => {\n                forEach(getAllPaths(nodeConnections[outcomeId], nodes, clone(path)), (path) => {\n                    allPathsForNode.push(path);\n                });\n            });\n        }\n    }\n\n    return allPathsForNode.sort((path1, path2) => path2.length - path1.length);\n};\n\nexport default getAllPaths;\n"]}