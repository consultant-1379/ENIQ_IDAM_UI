{"version":3,"sources":["../../../../../../../XUI/org/forgerock/commons/ui/common/util/ObjectUtil.js"],"names":["define","_","obj","toJSONPointerMap","originalObject","pointerList","chain","pairs","filter","p","undefined","map","indexOf","isEmpty","isArray","child","pointer","value","flatten","reduce","entry","getValueFromPointer","object","pathParts","split","shift","result","path","isObject","walkDefinedPath","finalPath","node","currentPathPart","length","isEqualSet","set1","set2","traverseSet","targetSet","sourceItem","find","targetItem","curry","findItemsNotInSet","item1","item2","isEqual","generatePatchSet","newObject","oldObject","newObjectClosure","oldObjectClosure","newPointerMap","previousPointerMap","newValues","finalPathToAdd","newValueAtFinalPath","oldValueAtFinalPath","setToPatchOperation","set","operation","item","concat","uniq","JSON","stringify","removedValues","finalPathToRemove"],"mappings":"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","file":"ObjectUtil.js","sourcesContent":["/**\r\n * The contents of this file are subject to the terms of the Common Development and\r\n * Distribution License (the License). You may not use this file except in compliance with the\r\n * License.\r\n *\r\n * You can obtain a copy of the License at legal/CDDLv1.0.txt. See the License for the\r\n * specific language governing permission and limitations under the License.\r\n *\r\n * When distributing Covered Software, include this CDDL Header Notice in each file and include\r\n * the License file at legal/CDDLv1.0.txt. If applicable, add the following below the CDDL\r\n * Header, with the fields enclosed by brackets [] replaced by your own identifying\r\n * information: \"Portions copyright [year] [name of copyright owner]\".\r\n *\r\n * Copyright 2011-2016 ForgeRock AS.\r\n */\r\n/* eslint-disable */\r\n define([\r\n    \"lodash\"\r\n], function (_) {\r\n    /**\r\n     * @exports org/forgerock/commons/ui/common/util/ObjectUtil\r\n     */\r\n\r\n    var obj = {};\r\n\r\n    /**\r\n     * Translates an arbitrarily-complex object into a flat one composed of JSONPointer key-value pairs.\r\n     * Example:\r\n     *   toJSONPointerMap({\"c\": 2, \"a\": {\"b\": ['x','y','z',true]}}) returns:\r\n     *   {/c: 2, /a/b/0: \"x\", /a/b/1: \"y\", /a/b/2: \"z\", /a/b/3: true}\r\n     * @param {object} originalObject - the object to convert to a flat map of JSONPointer values\r\n     */\r\n    obj.toJSONPointerMap = function (originalObject) {\r\n        var pointerList;\r\n        pointerList = function (obj) {\r\n            return _.chain(obj)\r\n                .pairs()\r\n                .filter(function (p) {\r\n                    return p[1] !== undefined;\r\n                })\r\n                .map(function (p) {\r\n                    if (_.indexOf([\"string\",\"boolean\",\"number\"], (typeof p[1])) !== -1 ||\r\n                        _.isEmpty(p[1]) ||\r\n                        _.isArray(p[1])) {\r\n                        return { \"pointer\": \"/\" + p[0], \"value\": p[1]};\r\n                    } else {\r\n                        return _.map(pointerList(p[1]), function (child) {\r\n                            return {\"pointer\": \"/\" + p[0] + child.pointer, \"value\": child.value };\r\n                        });\r\n                    }\r\n                })\r\n                .flatten(true)\r\n                .value();\r\n        };\r\n\r\n        return _.reduce(pointerList(originalObject), function (map, entry) {\r\n            map[entry.pointer] = entry.value;\r\n            return map;\r\n        }, {});\r\n    };\r\n\r\n    /**\r\n     * Uses a JSONPointer string to find a value within a provided object\r\n     * Examples:\r\n     *   getValueFromPointer({test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}, \"/test/0\") returns: \"apple\"\r\n     *   getValueFromPointer({test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}, \"/test/1/foo\") returns: \"bar\"\r\n     *   getValueFromPointer({test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}, \"/test/1\") returns:\r\n     *      {\"foo\":\"bar\", \"hello\": \"world\"}\r\n     *   getValueFromPointer({test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}, \"/test2\") returns: undefined\r\n     *   getValueFromPointer({test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}, \"/\") returns:\r\n            {test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}\r\n     *\r\n     * @param {object} object - the object to search within\r\n     * @param {string} pointer - the JSONPointer to use to find the value within the object\r\n     */\r\n    obj.getValueFromPointer = function (object, pointer) {\r\n        var pathParts = pointer.split(\"/\");\r\n        // remove first item which came from the leading slash\r\n        pathParts.shift(1);\r\n        if (pathParts[0] === \"\") { // the case when pointer is just \"/\"\r\n            return object;\r\n        }\r\n\r\n        return _.reduce(pathParts, function (result, path) {\r\n            if (_.isObject(result)) {\r\n                return result[path];\r\n            } else {\r\n                return result;\r\n            }\r\n        }, object);\r\n    };\r\n\r\n    /**\r\n     * Look through the provided object to see how far it can be traversed using a given JSONPointer string\r\n     * Halts at the first undefined entry, or when it has reached the end of the pointer path.\r\n     * Returns a JSONPointer that represents the point at which it was unable to go further\r\n     * Examples:\r\n     *   walkDefinedPath({test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}, \"/test/0\") returns: \"/test/0\"\r\n     *   walkDefinedPath({test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}, \"/test/3/foo\") returns: \"/test/3\"\r\n     *   walkDefinedPath({test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}, \"/missing\") returns: \"/missing\"\r\n     *   walkDefinedPath({test:[\"apple\", {\"foo\":\"bar\", \"hello\": \"world\"}]}, \"/missing/bar\") returns: \"/missing\"\r\n     *\r\n     * @param {object} object - the object to walk through\r\n     * @param {string} pointer - the JSONPointer to use to walk through the object\r\n     */\r\n    obj.walkDefinedPath = function (object, pointer) {\r\n        var finalPath = \"\",\r\n            node = object,\r\n            currentPathPart,\r\n            pathParts = pointer.split(\"/\");\r\n\r\n        // remove first item which came from the leading slash\r\n        pathParts.shift(1);\r\n\r\n        // walk through the path, stopping when hitting undefined\r\n        while (node !== undefined && node !== null && pathParts.length) {\r\n            currentPathPart = pathParts.shift(1);\r\n            finalPath += (\"/\" + currentPathPart);\r\n            node = node[currentPathPart];\r\n        }\r\n\r\n        // if the whole object needs to be added....\r\n        if (finalPath === \"\") {\r\n            finalPath = \"/\";\r\n        }\r\n        return finalPath;\r\n    };\r\n\r\n    /**\r\n     * Compare to Array values, interpeted as sets, to see if they contain the same values.\r\n     * Important distinctive behavior of sets - order doesn't matter for equality.\r\n     * @param {Array} set1 - an set of any values. Nested Arrays will also be interpreted as sets.\r\n     * @param {Array} set2 - an set of any values. Nested Arrays will also be interpreted as sets.\r\n     * Examples:\r\n     *  isEqualSet([1], [1]) -> true\r\n     *  isEqualSet([1], [1,3]) -> false\r\n     *  isEqualSet([3,1], [1,3]) -> true\r\n     *  isEqualSet([3,{a:1},1], [1,3,{a:1}]) -> true\r\n     *  isEqualSet([3,{a:1},1], [1,3,{a:2}]) -> false\r\n     *  isEqualSet([3,{a:1},['b','a'],1], [1,3,{a:1},['a','b']]) -> true\r\n     */\r\n    obj.isEqualSet = function (set1, set2) {\r\n        var traverseSet = function (targetSet, result, sourceItem) {\r\n            if (_.isArray(sourceItem)) {\r\n                return result && _.find(targetSet, function (targetItem) {\r\n                    return obj.isEqualSet(sourceItem,targetItem);\r\n                }) !== undefined;\r\n            } else if (_.isObject(sourceItem)) {\r\n                return result && _.find(targetSet, sourceItem) !== undefined;\r\n            } else {\r\n                return result && _.indexOf(targetSet, sourceItem) !== -1;\r\n            }\r\n        };\r\n\r\n        return _.reduce(set1, _.curry(traverseSet)(set2), true) &&\r\n                _.reduce(set2, _.curry(traverseSet)(set1), true);\r\n    };\r\n\r\n    /**\r\n     * Given a first set, return a subset containing all items which are not\r\n     * present in the second set.\r\n     * @param {Array} original set\r\n     * @param {Array} secondary to intersect with\r\n     * Examples:\r\n     *  findItemsNotInSet([1,2,3],[2,3]) -> [1]\r\n     *  findItemsNotInSet([1,2,3],[2,3,1]) -> []\r\n     *  findItemsNotInSet([1,{a:1},3],[3,1,{a:2}]) -> [{a:1}]\r\n     */\r\n    obj.findItemsNotInSet = function (set1, set2) {\r\n        return _.filter(set1, function (item1) {\r\n            return !_.find(set2, function (item2) {\r\n                return _.isEqual(item1,item2);\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Compares two objects and generates a patchset necessary to convert the second object to match the first\r\n     * Examples:\r\n     *   generatePatchSet({\"a\": 1, \"b\": 2}, {\"a\": 1}) returns:\r\n     *   [{\"operation\":\"add\",\"field\":\"/b\",\"value\":2}]\r\n     *\r\n     *   generatePatchSet({\"a\": 1, \"b\": 2}, {\"c\": 1}) returns:\r\n     *   [\r\n     *     {\"operation\":\"add\",\"field\":\"/a\",\"value\":1},\r\n     *     {\"operation\":\"add\",\"field\":\"/b\",\"value\":2},\r\n     *     {\"operation\":\"remove\",\"field\":\"/c\"}\r\n     *   ]\r\n     *\r\n     *   generatePatchSet({\"a\": [1,2]}, {\"a\": [1,3]}) returns:\r\n     *   [\r\n     *     {\"operation\":\"add\",\"field\":\"/a/-\",\"value\":2},\r\n     *     {\"operation\":\"remove\",\"field\":\"/a\",\"value\":3}\r\n     *   ]\r\n     *\r\n     * @param {object} newObject - the object to build up to\r\n     * @param {object} oldObject - the object to start from\r\n     */\r\n    obj.generatePatchSet = function (newObject, oldObject) {\r\n        var newObjectClosure = newObject, // needed to have access to newObject within _ functions\r\n            oldObjectClosure = oldObject, // needed to have access to oldObject within _ functions\r\n            newPointerMap = obj.toJSONPointerMap(newObject),\r\n            previousPointerMap = obj.toJSONPointerMap(oldObject),\r\n            newValues = _.chain(newPointerMap)\r\n                .pairs()\r\n                .filter(function (p) {\r\n                    if (_.isArray(previousPointerMap[p[0]]) && _.isArray(p[1])) {\r\n                        return !obj.isEqualSet(previousPointerMap[p[0]], p[1]);\r\n                    } else {\r\n                        return !_.isEqual(previousPointerMap[p[0]], p[1]);\r\n                    }\r\n                })\r\n                .map(function (p) {\r\n                    var finalPathToAdd = obj.walkDefinedPath(oldObjectClosure, p[0]),\r\n                        newValueAtFinalPath = obj.getValueFromPointer(newObjectClosure, finalPathToAdd),\r\n                        oldValueAtFinalPath = obj.getValueFromPointer(oldObjectClosure, finalPathToAdd),\r\n                        setToPatchOperation = function (set, operation, path) {\r\n                            return _.map(set, function (item) {\r\n                                return {\r\n                                    \"operation\": operation,\r\n                                    \"field\": path,\r\n                                    \"value\": item\r\n                                };\r\n                            });\r\n                        };\r\n                    if (_.isArray(newValueAtFinalPath) && _.isArray(oldValueAtFinalPath)) {\r\n                        return setToPatchOperation(\r\n                                obj.findItemsNotInSet(newValueAtFinalPath, oldValueAtFinalPath),\r\n                                \"add\",\r\n                                finalPathToAdd + \"/-\" // add to set syntax\r\n                            ).concat(setToPatchOperation(\r\n                                obj.findItemsNotInSet(oldValueAtFinalPath, newValueAtFinalPath),\r\n                                \"remove\",\r\n                                finalPathToAdd\r\n                            ));\r\n                    } else if (newValueAtFinalPath === null) {\r\n                        return {\r\n                            \"operation\": \"remove\",\r\n                            \"field\": finalPathToAdd\r\n                        };\r\n                    } else {\r\n                        return {\r\n                            \"operation\": (oldValueAtFinalPath === undefined) ? \"add\" : \"replace\",\r\n                            \"field\": finalPathToAdd,\r\n                            \"value\": newValueAtFinalPath\r\n                        };\r\n                    }\r\n                })\r\n                .flatten()\r\n                // Filter out duplicates which might result from adding whole containers\r\n                // Have to stringify the patch operations to do object comparisons with uniq\r\n                .uniq(JSON.stringify)\r\n                .value(),\r\n            removedValues = _.chain(previousPointerMap)\r\n                .pairs()\r\n                .filter(function (p) {\r\n                    return obj.getValueFromPointer(newObjectClosure, p[0]) === undefined;\r\n                })\r\n                .map(function (p) {\r\n                    var finalPathToRemove = obj.walkDefinedPath(newObjectClosure, p[0]);\r\n                    return { \"operation\": \"remove\", \"field\": finalPathToRemove };\r\n                })\r\n                // Filter out duplicates which might result from deleting whole containers\r\n                // Have to stringify the patch operations to do object comparisons with uniq\r\n                .uniq(JSON.stringify)\r\n                .value();\r\n\r\n        return newValues.concat(removedValues);\r\n    };\r\n\r\n    return obj;\r\n});"]}